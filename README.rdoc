= ruby-prof

{<img src="https://travis-ci.org/ruby-prof/ruby-prof.png?branch=master" alt="Build Status" />}[https://travis-ci.org/ruby-prof/ruby-prof]

== Overview

ruby-prof is a code profiler for MRI Ruby.  Its features include:

* Speed - it is a C extension and therefore many times faster than the standard Ruby profiler.
* Modes - Ruby prof can measure different parameters, including wall time, process time object allocations and memory usage
* Reports - can generate text and cross-referenced html reports
  - Flat Profiles - similar to the reports generated by the standard Ruby profiler
  - Graph profiles - similar to GProf, these show how long a method runs, which methods call it and which methods it calls.
  - Call tree profiles - outputs results in the calltree format suitable for the KCacheGrind profiling tool.
  - Many more -- see reports section of this \README.
* Threads - supports profiling multiple threads simultaneously

== Why ruby-prof

You want to use ruby-prof if your program is slow and you don't know why. It will help you track down methods that are
either slow, allocate a number of objects or allocate high memory use objects. Most of the time the results will be
suprising - when profiling what you think you know almost always turns out to be wrong.

Because ruby-prof is built using ruby's C tracepoint api, it knows a whole lot about your program. However, that also comes
with two caveats:

* To use ruby-prof you generally need to include a few lines of extra code in your program (although see command line usage above)
* Using ruby-prof will cause your program to run slower (see Performance section below)

Most of the time, these two caveats are acceptable. But if you need to figure out why a program running in production is slow or hung,
a sampling profiler will be a better choice. Excellent choices include stackprof or rbspy.

If you are just interested in memory usage, you may also want to checkout the memory_profiler gem (although ruby-prof provides
similar information).

== Requirements

ruby-prof requires Ruby 2.4.0 or higher.

If you are running Linux or Unix you'll need a C compiler so the
extension can be compiled when it is installed.

If you are running Windows, then you may need to install the
Windows specific RubyGem which includes an already built extension (see Install section).

== Install

The easiest way to install ruby-prof is by using Ruby Gems.  To
install:

    gem install ruby-prof

If you're on windows then please install the already compiled version or install devkit so that it
can compile.

== Usage

There are three major options for running ruby-prof: via the command
line, via its convenience API or via its core API.

=== ruby-prof Executable

The first is to use ruby-prof to run the Ruby program you want to
profile.  For more information refer to the documentation of the
ruby-prof command:

    $ ruby-prof -h


=== ruby-prof Convenience API

The second way is to use the ruby-prof convenience API to profile
particular segments of code.

    require 'ruby-prof'

    # profile the code
    RubyProf.start
    # ... code to profile ...
    result = RubyProf.stop

    # print a flat profile to text
    printer = RubyProf::FlatPrinter.new(result)
    printer.print(STDOUT)

Alternatively, you can use a block to tell ruby-prof what to profile:

    require 'ruby-prof'

    # profile the code
    result = RubyProf.profile do
      # ... code to profile ...
    end

    # print a graph profile to text
    printer = RubyProf::GraphPrinter.new(result)
    printer.print(STDOUT, {})

Note the RubyProf.profile method can take a list of optionw, which are
described below.

ruby-prof also supports pausing and resuming profiling runs.

    require 'ruby-prof'

    # profile the code
    RubyProf.start
    # ... code to profile ...

    RubyProf.pause
    # ... other code ...

    RubyProf.resume
    # ... code to profile ...
    result = RubyProf.stop

Note that resume will only work if start has been called previously.
In addition, resume can also take a block:

    require 'ruby-prof'

    RubyProf.resume do
      # ... code to profile...
    end

    result = RubyProf.stop

With this usage, resume will automatically call pause at the
end of the block.

=== Profile Class

The convenience API is a wrapper around the the Ruby::Profile class. Using the class directly
provides addition functionality, such as method exclusion.

To create a new profile:

    require 'ruby-prof'

    profile = RubyProf::Profile.new(options)
    result = profile.profile do
               ...
             end

Options include:

   measure_mode::
       One of the measure modes, the default is wall time

   track_allocations::
       Tracks each object location, incuding the object class, memory size and source file location

   exclude_threads::
       Array of threads which should not be profiled.

   include_threads::
       Array of threads which should be profiled. All other threads will
       be ignored.

Once a profile is completed, you can either generate a report via a printer or save the results for later analysis.
Results can be saved using the standard Ruby marshal library:

    require 'ruby-prof'

    profile = RubyProf.profile(:measure_mode => RubyProf::ProcessTime, :track_allocations => true) do
               ...
              end

    data = Marshal.dump(profile)
    File.open('some file', 'wb') do |file|
      file << data
    end

    # Sometime later
    data = File.read('some file')
    profile = Marshal.load(data)

== Method Exclusion

ruby-prof supports excluding specific methods and threads from
profiling results. This is useful for reducing connectivity in the
call graph, making it easier to identify the source of performance
problems when using a graph printer.

For example, consider <tt>Integer#times</tt>: it's hardly ever useful
to know how much time is spent in the method itself. We're much more
interested in how much the passed in block contributes to the time
spent in the method which contains the <tt>Integer#times</tt> call.

The effect on collected metrics are identical to eliminating methods from the
profiling result in a post process step.

    profile = RubyProf::Profile.new(...)
    profile.exclude_methods!(Integer, :times, ...)
    profile.start

A convenience method is provided to exclude a large number of methods
which usually clutter up profiles:

    profile.exclude_common_methods!

However, this is a somewhat opinionated method collection. It's
usually better to view it as an inspiration instead of using it
directly (see https://github.com/ruby-prof/ruby-prof/blob/e087b7d7ca11eecf1717d95a5c5fea1e36ea3136/lib/ruby-prof/profile/exclude_common_methods.rb).


== Profiling Rails

To profile a Rails application it is vital to run it using production like
settings (cache classes, cache view lookups, etc.).  Otherwise, Rail's
dependency loading code will overwhelm any time spent in the application
itself (our tests show that Rails dependency loading causes a roughly 6x
slowdown).  The best way to do this is create a new Rails environment,
profile.rb.

So to profile Rails:

1. Create a new profile.rb environment. Make sure to turn on
   <tt>cache_classes</tt> and
   <tt>cache_template_loading</tt>. Otherwise your profiling results
   will be overwhelmed by the time Rails spends loading required
   files. You should likely turn off caching.

2. Add the ruby-prof to your gemfile:

    group :profile do
      gem 'ruby-prof'
    end

3. Add the ruby prof rack adapter to your middleware stack.  One way to
   do this is by adding the following code to <tt>config.ru</tt>:

    if Rails.env.profile?
      use Rack::RubyProf, :path => './tmp/profile'
    end

   The path is where you want profiling results to be stored.  By default the
   rack adapter will generate a html call graph report and flat text report.

4. Now make a request to your running server.  New profiling
   information will be generated for each request.  Note that each
   request will overwrite the profiling reports created by the
   previous request!

== Reports

ruby-prof can generate a number of different reports:

* Flat Reports
* Graph Reports
* HTML Graph Reports
* Call graphs
* Call stack reports
* More!

Flat profiles show the overall time spent in each method. They
are a good way of quickly identifying which methods take the most time.
An example of a flat profile and an explanation can be found in
{examples/flat.txt}[http://github.com/ruby-prof/ruby-prof/tree/master/examples/flat.txt].

There are several varieties of these - run <tt>ruby-prof --help</tt>

Graph profiles also show the overall time spent in each method. In
addition, they also show which methods call the current method and which
methods its calls.  Thus they are good for understanding how methods
gets called and provide insight into the flow of your program. An
example text graph profile is located at
{examples/graph.txt}[http://github.com/ruby-prof/ruby-prof/tree/master/examples/graph.txt].

HTML Graph profiles are the same as graph profiles, except output is
generated in hyper-linked HTML. Since graph profiles can be quite large,
the embedded links make it much easier to navigate the results. An
example html graph profile is located at
{examples/graph.html}[http://github.com/ruby-prof/ruby-prof/tree/master/examples/graph.html].

Call graphs output results in the calltree profile format which is used
by KCachegrind. Call graph support was generously donated by Carl
Shimer. More information about the format can be found at the
{KCachegrind}[http://kcachegrind.sourceforge.net/cgi-bin/show.cgi/KcacheGrindCalltreeFormat]
site.

Call stack reports produce a HTML visualization of the time spent in
each execution path of the profiled code. An example can be found at
{examples/stack.html}[http://github.com/ruby-prof/ruby-prof/tree/master/examples/stack.html].

Another good example: http://twitpic.com/28z94a

Finally, there's a so called MultiPrinter which can generate several
reports in one profiling run. See
{examples/multi.stack.html}[http://github.com/ruby-prof/ruby-prof/tree/master/examples/multi.stack.html].

There is also a graphviz .dot visualiser.

== Printers

Reports are created by printers.  Supported printers include:

RubyProf::FlatPrinter::
  Creates a flat report in text format

RubyProf::FlatPrinterWithLineNumbers::
  Same as above but more verbose

RubyProf::GraphPrinter::
  Creates a call graph report in text format

RubyProf::GraphHtmlPrinter::
  Creates a call graph report in HTML (separate files per thread)

RubyProf::DotPrinter::
  Creates a call graph report in GraphViz's DOT format which can be converted to an image

RubyProf::CallTreePrinter::
  Creates a call tree report compatible with KCachegrind

RubyProf::CallStackPrinter::
  Creates a HTML visualization of the Ruby stack

RubyProf::MultiPrinter::
  Uses the other printers to create several reports in one profiling run

Most printers are used in the following way:

    result = RubyProf.stop
    printer = RubyProf::GraphPrinter.new(result)
    printer.print(STDOUT, :min_percent => 2)

The first parameter is any writable IO object such as <tt>STDOUT</tt>
or a file.  The second parameter, specifies the minimum percentage a
method must take to be printed.  Percentages should be specified as
integers in the range 0 to 100.  For more information please see the
documentation for the different printers.

The other option is <tt>:print_file => true</tt> (default false),
which adds the filename to the output (GraphPrinter only).

<tt>MultiPrinter</tt> and <tt>CallTreePrinter</tt>differ from the
other printers in that they require a directory path and a profile
basename for the files they produce:

    printer = RubyProf::MultiPrinter.new(result)
    printer.print(:path => ".", :profile => "profile")

The values given in the example above are the defaults.

== Measurements

Depending on the mode and platform, ruby-prof can measure various
aspects of a Ruby program. Supported measurements include:

RubyProf::WALL_TIME::
  Wall time measures the real-world time
  elapsed between any two moments.  If there are other processes
  concurrently running on the system that use significant CPU or disk
  time during a profiling run then the reported results will be larger
  than expected. On Windows, wall time is measured using GetTickCount(),
  on MacOS by mach_absolute_time and on Linux and other Unix variants
  by clock_gettime.

RubyProf::PROCESS_TIME::
  Process time measures the time used by a process between any two moments.
  It is unaffected by other processes concurrently running
  on the system. Remember with process time that calls to methods like
  sleep will not be included in profiling results. On Windows, process time
  is measured using GetProcessTimes and on other platforms clock_gettime is used.

RubyProf::ALLOCATIONS::
  Object allocation reports show how many objects each method in
  a program allocates.

RubyProf::MEMORY::
  Memory usage reports show how much memory each method in a program
  uses.

To set the measurement:

    RubyProf.measure_mode = RubyProf::WALL_TIME
    RubyProf.measure_mode = RubyProf::PROCESS_TIME
    RubyProf.measure_mode = RubyProf::ALLOCATIONS
    RubyProf.measure_mode = RubyProf::MEMORY

The default value is <tt>RubyProf::WALL_TIME</tt>.

You may also specify the measure mode by using the
<tt>RUBY_PROF_MEASURE_MODE</tt> environment variable:

    export RUBY_PROF_MEASURE_MODE=wall
    export RUBY_PROF_MEASURE_MODE=process
    export RUBY_PROF_MEASURE_MODE=allocations
    export RUBY_PROF_MEASURE_MODE=memory

== Allocation Tracking

ruby-prof has the ability to track object allocations. This functionality can be turned on via the
track_allocations option:

    require 'ruby-prof'

    RubyProf.profile(:track_allocations => true) do
      ...
    end

Note the RubyProf::ALLOCATTIONS measure mode is slightly different than tracking allocations.  The measurement
mode provides high level information about the number of allocations performed in each method. In contrast, tracking
allocations provides detailed information about the type, number, memory usage and location of each allocation.
Currently, to see allocations results you must use the RubyProf::GraphHtmlPrinter.

== Multi-threaded Applications

ruby-prof can profile multiple simultaneous threads. Sometimes this
can be overwhelming, for example when using minitest and seeing tens
of worker threads (note to tell minitest to use a single thread set
the N environmental variable like this ENV["N"] = "0"). Thus, ruby-prof
provides two options to specify which threads should be profiled:

   exclude_threads::
       Array of threads which should not be profiled.

   include_threads::
       Array of threads which should be profiled. All other threads will
       be ignored.

== Performance

Significant effort has been put into reducing ruby-prof's overhead. Our tests show that the
overhead associated with profiling code varies considerably with the code being
profiled.  Most programs will run approximately twice as slow while highly recursive
programs (like the fibonacci series test) will run up to five times slower.

== Editing links

Use <tt>RUBY_PROF_EDITOR_URI</tt> environment variable to open source
code files in your favorite text editor. For example,
<tt>RUBY_PROF_EDITOR_URI=atm</tt> will produce links for Atom text
editor.

== License

See LICENSE for license information.

== API Documentation

The ruby-prof API documentation for the latest released gem version
can be found here: http://www.rubydoc.info/gems/ruby-prof/

The ruby-prof API documentation for the master branch is available
here: http://www.rubydoc.info/github/ruby-prof/ruby-prof/

== Development

Code is located at https://github.com/ruby-prof/ruby-prof

Google group/mailing list: http://groups.google.com/group/ruby-optimization or open a github issue.

== Version 1.0

ruby-prof's development stretches all the way back to 2005.  Fourteen years later, it seems
time for version 1.0! Version 1.0 is a significant update that greatly improves the internals of
ruby-prof and adds a number of improvements:

* Profiling is significantly faster
* The ability to measure allocations and memory usage using a standard (unpatched) version of ruby
* The ability to save and reload profiling results for later analysis
* The ability track object allocations

At the same time, it was also time to remove old code and deprecated methods. These changes include:

* Drop support for old versions of ruby. Currently 2.4 and up are required.
* Remove support for method elimination (instead use method exclusion described above)
* Remove the CPU_TIME measurement mode since it duplicates the PROCESS_TIME mode and
  required inline assembly code
* Remove the GC_TIME and GC_RUNS measurement modes since they required patched ruby versions. In modern
  ruby it is possible to reimplement this functionality, but it does not seem of that much value (shout
  out if you want it back).
